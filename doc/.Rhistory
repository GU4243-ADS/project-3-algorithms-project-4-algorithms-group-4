if (is.vector(x)) {
x <- data.frame(
class = paste0(class(x), " vector"),
length = length(x),
NAs = anyNA(x)
)
}
print(x)
}
know(aic)
know <- function(x) {
if (is.matrix(x) | is.data.frame(x)) {
x <- data.frame(
class = class(x),
dim = paste(dim(x)[1], dim(x)[2], sep = ", "),
anyNA = anyNA(x)
)
}
if (is.vector(x)) {
x <- data.frame(
class = paste0(class(x), " vector"),
length = length(x),
NAs = anyNA(x)
)
}
print(x)
}
know(aic)
know <- function(x) {
if (is.matrix(x) | is.data.frame(x)) {
x <- data.frame(
class = class(x),
dim = paste(dim(x)[1], dim(x)[2], sep = ", "),
anyNA = anyNA(x)
)
}
if (is.vector(x)) {
x <- data.frame(
class = paste0(class(x), " vector"),
length = length(x),
NAs = anyNA(x)
)
}
print(x)
}
know <- function(x) {
if (is.matrix(x) | is.data.frame(x)) {
x <- data.frame(
class = class(x),
dim = paste(dim(x)[1], dim(x)[2], sep = ", "),
NAs = anyNA(x)
)
}
if (is.vector(x)) {
x <- data.frame(
class = paste0(class(x), " vector"),
length = length(x),
NAs = anyNA(x)
)
}
print(x)
}
know(aic)
e.step1 <- log(mu) + log(gamma) # numerator of aic using log probabilities
e.step2 <- logSumExp(mu * gamma) # normalizing
aic <- e.step1 - e.step2 # sum(which(aic != NA))
dim(aic)
know <- function(x) {
if (is.matrix(x) | is.data.frame(x)) {
x <- data.frame(
class = class(x),
dim = paste(dim(x)[1], dim(x)[2], sep = ", "),
NAs = anyNA(x)
)
}
if (is.array(x)) {
x <- data.frame(
class = class(x),
dim = paste(dim(x)[1], dim(x)[2],dim(x)[3], sep = ", "),
NAs = anyNA(x)
)
}
if (is.vector(x)) {
x <- data.frame(
class = paste0(class(x), " vector"),
length = length(x),
NAs = anyNA(x)
)
}
print(x)
}
know(aic)
aic <- NULL
e.step1 <- log(mu) + log(gamma) # numerator of aic using log probabilities
e.step2 <- logSumExp(mu * gamma) # normalizing
aic <- e.step1 - e.step2 # sum(which(aic != NA))
know(aic)
aic <- NULL
know(aic)
know(aic)
e.step1 <- log(mu) + log(gamma) # numerator of aic using log probabilities
e.step2 <- logSumExp(mu * gamma) # normalizing
aic <- e.step1 - e.step2 # sum(which(aic != NA))
know(aic)
aic <- matrix(1/C, nrow = length(users), ncol = C) # cluster assignment/probability matrix, dims = users, clusters
users <- rownames(data)
items <- colnames(data) # used items as a generic for both movies and vroots
mu <- rep(1/C, C)
gamma <- array(1/k, dim = c(length(items), C, k)) # dims = items(movies), clusters, ratings
aic <- matrix(1/C, nrow = length(users), ncol = C) # cluster assignment/probability matrix, dims = users, clusters
## Estimate Mu
mu <- apply(cluster.probs, 2, sum)/length(users) # dims = 1 x clusters
gamma <- function(k=1) { # this is func is just diagnostic for the moment
indicator.numer <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3? but how to use apply with multiple funcs and subsetting, maybe define a func like below?
{
indicator.numer[,,i][which(mov.train == i)] <- 1
}
indicator.numer <- aperm(indicator.numer, c(2,1,3))
# would transposing each sheet in the for loop be faster?
numer <- apply(indicator.numer, 3, function(x) x%*%aic)
numerator <- array(numer, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose aic rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% aic # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% aic # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%aic)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(numerator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
str(result)
}
know(data)
sum(which(is.na(data)))
which(is.na(data))
length(which(is.na(data)))
length(data)
#### Step 1 - Initial Conditions
set.seed(123)
#data <- mov.train[1:500, ] # subset for speed (until finished)
data[which(is.na(data))] <- 0
?rowSums()
length(which(rowSums(data) == 0))
system.time(gamma(k=3))
gamma <- function(k=1) { # this is func is just diagnostic for the moment
indicator.numer <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3? but how to use apply with multiple funcs and subsetting, maybe define a func like below?
{
indicator.numer[,,i][which(data == i)] <- 1 # indicator matrix to identify each instance in which user i rated movie j with rating k
}
indicator.numer <- aperm(indicator.numer, c(2,1,3))
# would transposing each sheet in the for loop be faster?
numer <- apply(indicator.numer, 3, function(x) x%*%aic)
numerator <- array(numer, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose aic rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% aic # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% aic # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%aic)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(numerator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
str(result)
} # end of the diagnostic func
system.time(gamma(k=3))
test <- matrix(sample(20, 24, replace = TRUE), nrow = 4, ncol = 6)
test <- matrix(1:24, nrow = 4, ncol = 6)
?array
test <- matrix(rep(1:24, 2), dim = c(4, 6, 2))
test <- array(rep(1:24, 2), dim = c(4, 6, 2))
test
test1 <- matrix(2, nrow = 6, ncol = 3)
test[,,1]%*%test1
new <- apply(test, 3, function(x) x%*%test1)
apply(test, 3, function(x) x%*%test1)
gamma <- function(k=1) { # this is func is just diagnostic for the moment
indicator.numer <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3? but how to use apply with multiple funcs and subsetting, maybe define a func like below?
{
indicator.numer[,,i][which(data == i)] <- 1 # indicator array to identify each instance in which user i rated movie j with rating k
}
indicator.numer <- aperm(indicator.numer, c(2,1,3)) # new dims = (movies/items, users, ratings)
# would transposing each sheet in the for loop be faster?
# maybe faster to transpose aic rather than aperm indicator.nomin
numer <- apply(indicator.numer, 3, function(x) x%*%aic) # each element of resulting array represents the sum of the class C aic wieghts of every user who rated that jth movie with that rating k. apply outputs matrix with weird dims = (length(seq_along(\the result of the func on each sheet\)), number of sheets in third margin)
numerator <- array(numer, c(length(items), C, k)) # puts data in the correct shape. dims = (movies, clusters, ratings)
#denominator <- indicator.denom %*% aic # dims = movies, clusters, ratings
indicator.denom[which(!is.na(data))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% aic # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%aic)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(numerator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
str(result)
} # end of the diagnostic func
system.time(new <- gamma(k=3))
know(new)
know(data)
unique(data)
know(data)
unique(as.vector(data))
test
unique(test)
unique(as.vector(test))
gamma <- function(k=1) { # this is func is just diagnostic for the moment
indicator.numer <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k)
# can this be done with an apply appoach? yes, apply and margin = 3? but how to use apply with multiple funcs and subsetting, maybe define a func like below?
{
indicator.numer[,,i][which(data == i)] <- 1 # indicator array to identify each instance in which user i rated movie j with rating k
}
indicator.numer <- aperm(indicator.numer, c(2,1,3)) # transposing so that the matrix is conformable to aic. new dims = (movies/items, users, ratings)
# would transposing each sheet in the for loop be faster?
# maybe faster to transpose aic rather than aperm indicator.nomin
numer <- apply(indicator.numer, 3, function(x) x%*%aic) # each element of resulting array represents the sum of the class C aic wieghts of every user who rated that jth movie with that rating k. apply() outputs matrix with weird dims = (length(seq_along(\the result of the func on each sheet\)), number of sheets in third margin)
numerator <- array(numer, c(length(items), C, k)) # puts data in the correct shape. dims = (movies, clusters, ratings)
#denominator <- indicator.denom %*% aic # dims = movies, clusters, ratings
indicator.denom[which(data != 0)] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% aic # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%aic)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(numerator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
result
} # end of the diagnostic func
system.time(new <- gamma(k=3))
know(new)
set.seed(123)
data <- mov.train[1:500, ] # subset for speed (until finished)
mov.train <- movie_UI # to clarify that this is training data, Note: the unrated user-movie combos are NA's
load(file = "../data/movie_pred.RData")
load(file = "../data/movie_UI.RData")
mov.train <- movie_UI # to clarify that this is training data, Note: the unrated user-movie combos are NA's
set.seed(123)
data <- mov.train[1:500, ] # subset for speed (until finished)
data[which(is.na(data))] <- 0 # Note: length(which(rowSums(data) == 0)) is 0 which means ther is extension on at least 1 dimension for each user, i.e. every user rated at least 1 movie
C <- 12 # Half of the movie genres according to IMDB
#k = 6 # number of ratings
users <- rownames(data)
items <- colnames(data) # used items as a generic for both movies and vroots
mu <- rep(1/C, C)
gamma <- array(1/k, dim = c(length(items), C, k)) # dims = items(movies), clusters, ratings
set.seed(123)
data <- mov.train[1:500, ] # subset for speed (until finished)
data[which(is.na(data))] <- 0 # Note: length(which(rowSums(data) == 0)) is 0 which means ther is extension on at least 1 dimension for each user, i.e. every user rated at least 1 movie
C <- 12 # Half of the movie genres according to IMDB
k = 3 # number of ratings
users <- rownames(data)
items <- colnames(data) # used items as a generic for both movies and vroots
mu <- rep(1/C, C)
gamma <- array(1/k, dim = c(length(items), C, k)) # dims = items(movies), clusters, ratings
aic <- matrix(1/C, nrow = length(users), ncol = C) # cluster assignment/probability matrix, dims = users, clusters
indicator.numer <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k)
# can this be done with an apply appoach? yes, apply and margin = 3? but how to use apply with multiple funcs and subsetting, maybe define a func like below?
{
indicator.numer[,,i][which(data == i)] <- 1 # indicator array to identify each instance in which user i rated movie j with rating k
}
know(indicator.numer)
know <- function(x) {
if (is.matrix(x) | is.data.frame(x)) {
x <- data.frame(
class = class(x),
dim = paste(dim(x)[1], dim(x)[2], sep = ", "),
NAs = anyNA(x)
)
}
if (is.array(x)) {
x <- data.frame(
class = class(x),
dim = paste(dim(x)[1], dim(x)[2],dim(x)[3], sep = ", "),
NAs = anyNA(x)
)
}
if (is.vector(x)) {
x <- data.frame(
class = paste0(class(x), " vector"),
length = length(x),
NAs = anyNA(x)
)
}
print(x)
}
know(indicator.numer)
indicator.numer <- aperm(indicator.numer, c(2,1,3)) # transposing so that the matrix is conformable to aic. new dims = (movies/items, users, ratings)
know(indicator.numer)
numer <- apply(indicator.numer, 3, function(x) x%*%aic) # each element of resulting array represents the sum of the class C aic wieghts of every user who rated that jth movie with that rating k. apply() outputs matrix with weird dims = (length(seq_along(\the result of the func on each sheet\)), number of sheets in third margin)
know(numer)
numerator <- array(numer, c(length(items), C, k)) # puts data in the correct shape. dims = (movies, clusters, ratings)
know(numerator)
indicator.denom[which(data != 0)] <- 1 # indicator array to identify each instance in which user i rated movie j with any rating
know(indicator.denom)
indicator.denom <- t(indicator.denom) # dims = movies, users
gamma <- function() { # this is func is just diagnostic for the moment
indicator.numer <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k)
# can this be done with an apply appoach? yes, apply and margin = 3? but how to use apply with multiple funcs and subsetting, maybe define a func like below?
{
indicator.numer[,,i][which(data == i)] <- 1 # indicator array to identify each instance in which user i rated movie j with rating k
}
indicator.numer <- aperm(indicator.numer, c(2,1,3)) # transposing so that the matrix is conformable to aic. new dims = (movies/items, users, ratings)
# would transposing each sheet in the for loop be faster?
# maybe faster to transpose aic rather than aperm indicator.nomin
numer <- apply(indicator.numer, 3, function(x) x%*%aic) # each element of resulting array represents the sum of the class C aic wieghts of every user who rated that jth movie with that rating k. apply() outputs matrix with weird dims = (length(seq_along(\the result of the func on each sheet\)), number of sheets in third margin)
numerator <- array(numer, c(length(items), C, k)) # puts data in the correct shape. dims = (movies, clusters, ratings)
indicator.denom[which(data != 0)] <- 1 # indicator array to identify each instance in which user i rated movie j with any rating
indicator.denom <- t(indicator.denom) # dims = movies, users.
demoninator <- indicator.denom %*% aic # each element of the resulting matrix represents the sum of the class C aic weights of every user who rated movie j with any rating. dims = (movies, clusters). Note: denominator is common across ratings k, but not across clusters, there for the following code would be unecessary: demoninator <- apply(indicator.denom, 3, function(x) x%*%aic)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(numerator, 3, function(x) x/demoninator) # divides each numerator element by its respective denominator value. apply() returns a weirdly shaped matrix again.
result <- array(result, c(length(items), C, k)) # puts data in the correct shape. dims = (movies, clusters, ratings)
result
} # end of the diagnostic func
system.time(new <- gamma())
know(new)
know(indicator.denom)
demoninator <- indicator.denom%*%aic # each element of the resulting matrix represents the sum of the class C aic weights of every user who rated movie j with any rating. dims = (movies, clusters). Note: denominator is common across ratings k, but not across clusters, there for the following code would be unecessary: demoninator <- apply(indicator.denom, 3, function(x) x%*%aic)
know(demoninator)
demoninator[1:5,1:8]
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(numerator, 3, function(x) x/demoninator) # divides each numerator element by its respective denominator value. apply() returns a weirdly shaped matrix again.
know(result)
length(seq_along(demoninator))
know
know(demoninator)
denominator <- demoninator
result <- array(result, c(length(items), C, k)) # puts data in the correct shape. dims = (movies, clusters, ratings)
know(result)
1619*12
length(which(is.na(result)))
sum(result[1,1,])
sum(result[2,2,])
aic[1:5,1:8]
colSums(aic)
sum(colSums(aic))
test <- aperm(numerator, c(1, 3, 2))
know(test)
sum(rowSums(test[,,1]))
k = 6 # number of ratings
gamma <- function() { # this is func is just diagnostic for the moment
set.seed(123)
indicator.numer <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k)
# can this be done with an apply appoach? yes, apply and margin = 3? but how to use apply with multiple funcs and subsetting, maybe define a func like below?
{
indicator.numer[,,i][which(data == i)] <- 1 # indicator array to identify each instance in which user i rated movie j with rating k
}
indicator.numer <- aperm(indicator.numer, c(2,1,3)) # transposing so that the matrix is conformable to aic. new dims = (movies/items, users, ratings)
# would transposing each sheet in the for loop be faster?
# maybe faster to transpose aic rather than aperm indicator.nomin
numer <- apply(indicator.numer, 3, function(x) x%*%aic) # each element of resulting array represents the sum of the class C aic wieghts of every user who rated that jth movie with that rating k. apply() outputs matrix with weird dims = (length(seq_along(\the result of the func on each sheet\)), number of sheets in third margin)
numerator <- array(numer, c(length(items), C, k)) # puts data in the correct shape. dims = (movies, clusters, ratings)
indicator.denom[which(data != 0)] <- 1 # indicator array to identify each instance in which user i rated movie j with any rating
indicator.denom <- t(indicator.denom) # dims = movies, users.
denominator <- indicator.denom%*%aic # each element of the resulting matrix represents the sum of the class C aic weights of every user who rated movie j with any rating. dims = (movies, clusters). Note: denominator is common across ratings k, but not across clusters, there for the following code would be unecessary: denominator <- apply(indicator.denom, 3, function(x) x%*%aic)
#result <- nominator/denominator # dims = movies, clusters, ratings
result <- apply(numerator, 3, function(x) x/denominator) # divides each numerator element by its respective denominator value. apply() returns a weirdly shaped matrix again.
result <- array(result, c(length(items), C, k)) # puts data in the correct shape. dims = (movies, clusters, ratings)
result
} # end of the diagnostic func
system.time(new <- gamma())
know(new)
length(which(is.na(new)))
load(file = "../data/movie_UI.RData")
mov.train <- movie_UI # to clarify that this is training data, Note: the unrated user-movie combos are NA's
data <- mov.train[1:500, ] # subset for speed (until finished)
data[which(is.na(data))] <- 0 # Note: length(which(rowSums(data) == 0)) is 0 which means ther is extension on at least 1 dimension for each user, i.e. every user rated at least 1 movie
C <- 12 # Half of the movie genres according to IMDB
k = 6 # number of ratings
users <- rownames(data)
items <- colnames(data) # used items as a generic for both movies and vroots
mu <- rep(1/C, C)
gamma <- array(1/k, dim = c(length(items), C, k)) # dims = items(movies), clusters, ratings
aic <- matrix(1/C, nrow = length(users), ncol = C) # cluster assignment/probability matrix, dims = users, clusters
gamma <- function() { # this is func is just diagnostic for the moment
set.seed(123)
indicator.numer <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k)
# can this be done with an apply appoach? yes, apply and margin = 3? but how to use apply with multiple funcs and subsetting, maybe define a func like below?
{
indicator.numer[,,i][which(data == i)] <- 1 # indicator array to identify each instance in which user i rated movie j with rating k
}
indicator.numer <- aperm(indicator.numer, c(2,1,3)) # transposing so that the matrix is conformable to aic. new dims = (movies/items, users, ratings)
# would transposing each sheet in the for loop be faster?
# maybe faster to transpose aic rather than aperm indicator.nomin
numer <- apply(indicator.numer, 3, function(x) x%*%aic) # each element of resulting array represents the sum of the class C aic wieghts of every user who rated that jth movie with that rating k. apply() outputs matrix with weird dims = (length(seq_along(\the result of the func on each sheet\)), number of sheets in third margin)
numerator <- array(numer, c(length(items), C, k)) # puts data in the correct shape. dims = (movies, clusters, ratings)
indicator.denom[which(data != 0)] <- 1 # indicator array to identify each instance in which user i rated movie j with any rating
indicator.denom <- t(indicator.denom) # dims = movies, users.
denominator <- indicator.denom%*%aic # each element of the resulting matrix represents the sum of the class C aic weights of every user who rated movie j with any rating. dims = (movies, clusters). Note: denominator is common across ratings k, but not across clusters, there for the following code would be unecessary: denominator <- apply(indicator.denom, 3, function(x) x%*%aic)
#result <- nominator/denominator # dims = movies, clusters, ratings
result <- apply(numerator, 3, function(x) x/denominator) # divides each numerator element by its respective denominator value. apply() returns a weirdly shaped matrix again.
result <- array(result, c(length(items), C, k)) # puts data in the correct shape. dims = (movies, clusters, ratings)
result
} # end of the diagnostic func
system.time(new <- gamma())
know(new)
know <- function(x) {
if (is.matrix(x) | is.data.frame(x)) {
x <- data.frame(
class = class(x),
dim = paste(dim(x)[1], dim(x)[2], sep = ", "),
NAs = anyNA(x)
)
}
if (is.array(x)) {
x <- data.frame(
class = class(x),
dim = paste(dim(x)[1], dim(x)[2],dim(x)[3], sep = ", "),
NAs = anyNA(x)
)
}
if (is.vector(x)) {
x <- data.frame(
class = paste0(class(x), " vector"),
length = length(x),
NAs = anyNA(x)
)
}
print(x)
}
know(new)
length(which(is.na(new)))
test <- aperm(new, c(1, 3, 2))
know(test)
rowSums(test[,,1])
test <- matrix(sample(20, 24, replace = TRUE), nrow = 4, ncol = 6)
test
test == 10
test + (test == 10)
?norm
test1 <- matrix(2, nrow = 6, ncol = 3)
test1 <- matrix(2, nrow = 6, ncol = 3)
test <- matrix(sample(20, 24, replace = TRUE), nrow = 4, ncol = 6)
norm(test - test1, type = "O")
test
test1
test1 <- matrix(2, nrow = 4, ncol = 6)
norm(test - test1, type = "O")
norm(test - test1, type = "2")
## Estimate Mu
mu <- apply(aic, 2, sum)/length(users) # dims = 1 x clusters
know(mu)
load(file = "../data/MS_UI.RData")
MS_UI[1:5,1:8]
log(.5)
data[1:5,1:8]
data[which(is.na(data))] <- 0
data <- mov.train[1:500, ]
data[which(is.na(data))] <- 0
new <- data[which(is.na(data))] <- 0
length(which(new != data))
data[which(is.na(data))] <- 0 # Note: length(which(rowSums(data) == 0)) is 0 which means ther is extension on at least 1 dimension for each user, i.e. every user rated at least 1 movie
data <- mov.train[1:500, ] # subset for speed (until finished)
data[1:5,1:8]
data[which(is.na(data))] <- 0 # Note: length(which(rowSums(data) == 0)) is 0 which means ther is extension on at least 1 dimension for each user, i.e. every user rated at least 1 movie
data[1:5,1:8]
new <- data
new[which(is.na(new))] <- 0
length(which(new != data))
unique(as.vector(data))
length(unique(as.vector(data)))
length(unique(as.vector(data))) - 1
length(unique(as.vector(MS_UI))) - 1
length(unique(as.vector(mov.train)))
unique(as.vector(mov.train))
test <- matrix(sample(20, 24, replace = TRUE), nrow = 4, ncol = 6)
test
apply(test, 1, which.max)
?which.max
(test == min(test))
(test == min(test)) + 0
?rowMins
(test == rowMins(test)) + 0
rowMins(test)
test
test[4,4] <- 5
test
(test == rowMins(test)) + 0
test[3,4] <- 5
test
(test == rowMins(test)) + 0
rowOrderStats(test)
rowOrderStats(test, which = 1)
rowSums(test)
rowsum(test)
(test == rowMins(test)) + 0
new <- (test == rowMins(test)) + 0
new + FALSE
new + FALSE
FALSE + new
as.logical(new)
5*5
exp(log(5)+log(5))
5*5
exp(log(5)+log(5))
