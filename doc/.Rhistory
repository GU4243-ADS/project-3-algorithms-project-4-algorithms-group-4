{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x*demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
str(result)
}
system.time(gamma())
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
head(indicator.nomin)
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 t
head(indicator.nomin)
mov.train[3]
mov.train[3,1]
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
indicator.nomin[1,3]
indicator.nomin[1,3,1]
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
head(cluster.probs)
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x*demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
str(result)
}
system.time(gamma())
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
indicator.nomin[1,3]
indicator.nomin[1,3,1]
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
str(result)
}
system.time(gamma())
max(result)
test2
test1
test
max(test)
?return
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
return(str(result), max(result))
}
system.time(gamma())
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
return(str(result))
return(max(result))
}
system.time(gamma())
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
return(str(result))
return(max(result))
}
system.time(gamma())
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
#return(str(result))
return(max(result))
}
system.time(gamma())
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
return(str(result))
return(max(result[,,1])))
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
return(str(result))
return(max(result[,,1]))
}
system.time(gamma())
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
list(str(result), max(result[,,1])
}
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
list(str(result), max(result[,,1]))
}
system.time(gamma())
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
max(result[,,1])
}
system.time(gamma())
?load
?attach
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
attach(result)
}
system.time(gamma())
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
result
}
system.time(gamma())
head(result)
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
list(a = result)
}
system.time(gamma())
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,1][which(mov.train == 6)] <- 1 # return 1 to i and 6 to i
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
str(result)
}
system.time(gamma())
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,i][which(mov.train == i)] <- 1
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
str(result)
}
system.time(gamma())
gamma <- function(k=1) {
#k = 1
C = 6
cluster.probs <- matrix((1/6), nrow = length(users), ncol = C) # dims = users, clusters
indicator.nomin <- array(0, dim = c(length(users),length(items), k))
indicator.denom <- matrix(0, nrow = length(users), ncol = length(items))
for (i in 1:k) #can this be done with an apply appoach? yes, apply and margin = 3?
{
indicator.nomin[,,i][which(mov.train == i)] <- 1
}
indicator.nomin <- aperm(indicator.nomin, c(2,1,3))
# would transposing each sheet in the for loop be faster?
nomin <- apply(indicator.nomin, 3, function(x) x%*%cluster.probs)
nominator <- array(nomin, c(length(items), C, k)) # dims = movies, clusters, ratings
# maybe faster to transpose cluster.probs rather than aperm indicator.nomin
#nominator <- indicator.nomin %*% cluster.probs # dims = movies, clusters, ratings
indicator.denom[which(!is.na(mov.train))] <- 1
indicator.denom <- t(indicator.denom) # dims = movies, users
#denominator is common across ratings k, but not across clusters
demoninator <- indicator.denom %*% cluster.probs # dims = movies, clusters
#demoninator <- apply(indicator.denom, 3, function(x) x%*%cluster.probs)
#result <- nominator/demoninator # dims = movies, clusters, ratings
result <- apply(nominator, 3, function(x) x/demoninator)
result <- array(result, c(length(items), C, k)) # dims = movies, clusters, ratings
str(result)
}
system.time(gamma())
apply(cluster.probs, 2, sum)
sum(apply(cluster.probs, 2, sum))
apply(cluster.probs, 2, sum)/length(users)
